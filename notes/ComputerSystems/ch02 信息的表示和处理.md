# ch02 信息的表示和处理

单个的位不是非常有用，但是把位组合在一起，再加上某种解释，就赋予模式不同的含义。

**无符号**编码基于传统的二进制表示法，表示大于或等于零的数字。

**补码**编码是表示有符号整数的最常见方式，有符号整数就是可以为正或者为负的数字。

**浮点数**编码是表示实数的科学计数法的以2为基数的版本。

计算机的表示法是用有限数量的位来对一个数字编码，如果数字太大不能表示时，运算就会**溢出**，溢出会导致未知的结果。

---
##2.1 信息存储

大多数计算机使用8位的块，或者**字节**(byte)作为最小的可寻址的内存单位。机器及程序将内存视为一个非常大的字节数组，称为**虚拟内存**。内存的每个字节都由一个唯一的数字来标识，称它为**地址**
，所有的可能地址的集合就称为**虚拟地址空间**。

###2.1.1 十六进制表示法

**十六进制**(hex)使用数字‘0’～‘9’以及字符‘A’～‘F’来表示16个可能的值。在c语言中，以0x或0X开头的数字常量标示。

###2.1.2 字数据大小

每台计算机都有一个**字长**，指明指针数据的标志大小。

`如果程序以32位编译，在64位机器上可能可以运行，如果在64位机器编译的，在32位绝对没办法运行(这是一种向后兼容)。`

###2.1.3 寻址和字节顺序

最低有效字节在最前面的方式，称为**小端法**，最高有效字节在最前面的方式，称为**大端法**。

###2.1.4 表示字符串

c语言中字符串被编码一个以null(其值为0)字符结尾的字符数组。

###2.1.5 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。没有办法移植。

###2.1.6 布尔代数简介

**与**`&`：都为真时结果为真；

**或**`|`：有一个为真时结果为真；

**取反**`~`： 对某一个值进行按位取反操作；

**异或**`^`： 当某一个值为真，但不同时为真时，结果为真。

###2.1.7 C语言中的位级运算

C语言的一个很有用的特性就是它支持按位布尔运算。位级运算的一个常见用法就是实体**掩码**运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。

###2.1.8 C语言中的逻辑运算

C语言还提供了一组逻辑运算符**与**`||`、**或**`&&`、**非**`！`，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符&&和||就不会对第二个参数求值。

###2.1.9 C语言中的移位运算

C语言中还提供了一组**移位**运算，向左或者向右移动位模式。**逻辑右移**就是在左端补移位的0，**算数右移**是在左端补移位的最高有效位的值(对有符号位一般都算数移位)。

---
##2.2 整数表示

###2.2.1 整型数据类型

C语言支持多种整型数据类型--表示有限范围的整数。负数的范围比整数的范围大1。

###2.2.2 无符号的编码

###2.2.3 补码编码

非整型的值最高位为符号位，如果符号位为1表示为负数，0表示是正数

**补码**：按位取反加1

###2.2.4 有符号和无符号数之间的转换

处理同样字长的符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。

###2.2.5 C语言中的有符号数和无符号数

尽管C语言标准没有指定有符号数要采用某种表示但是几乎所有的机器都使用补码，大多数数字都默认认为是有符号的。如果无符号和有符号的进行运算的话，会隐式的将有符号参数转换成无符号，然后执行操作。

###2.2.6 扩展一个数字的位表示

从一个较小的数据类型转换到一个较大的类型，应该总是可能的。

要将一个无符号整数转换成一个更大的数据类型，我们只要简单的在表示的开头添加0，这种运算被称为**零拓展**。

要将一个补码数字转换为一个更大的数据类型，可以执行一个**符号扩展**，在表示中添加最高有效位的值。

###2.2.7 截断数字

当把32位转成16位的时候，比如53191，符号拓展位就设置为1，从而变成-12345的32位补码表示。

###2.2.8 关于有符号数与无符号数的建议

就像我们看到的那样，有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细微差别的错误很难被发现。

---
##2.3 整数运算

两个正数相加会得出一个负数，这些属性是由于计算机运算的有限性造成的。

###2.3.1 无符号加法

无符号数加法是溢出是无符号从0开始，无符号数取反也是正数。

###2.3.2 补码加法